//
// Created by Ovanes on 3/22/20.
//

// Проверка на простоту, Алгоритм Миллера — Рабина
//        ограничение по времени на тест 1 секунда
//        ограничение по памяти на тест 256 мегабайт
//        ввод стандартный ввод
//        вывод стандартный вывод
//
// Дано n натуральных чисел ai. Определите для каждого числа, является ли оно простым.
// Входные данные
// Программа получает на вход число n, 1 ≤ n ≤ 1000 и далее n чисел ai, 1 ≤ ai ≤ 1018.
//
// Выходные данные
// Если число ai простое, программа должна вывести YES, для составного числа программа должна вывести NO.

#include <iostream>
#include <map>
#include <random>
#include <cassert>


unsigned long long moduloMultiply(unsigned long long lhs, unsigned long long rhs, unsigned long long modulo) {
    unsigned long long res = 0; // Initialize result

    // Update lhs if it is more than or equal to modulo

    lhs %= modulo;

    while (rhs) {
        // If rhs is odd, add lhs with result
        if (rhs & 1)
            res = (res + lhs) % modulo;

        // Here we assume that doing 2 * lhs doesn't cause overflow
        lhs = (2 * lhs) % modulo;

        rhs >>= 1; // rhs = rhs / 2
    }

    return res;
}

unsigned long long int power(unsigned long long int num, unsigned long long int degree, unsigned long long int mod) {
    if (degree == 0) {
        return 1;
    }

    if (degree == 1) {
        return num % mod;
    }

    if (degree % 2 == 0) {
        auto r = power(num, degree / 2, mod);

        return moduloMultiply(r, r, mod);
    }

    auto r = power(num, degree / 2, mod);
    auto in = moduloMultiply(num, r, mod);

    return moduloMultiply(in, r, mod);
}


bool isPrime(unsigned long long candidate) {

    int accuracy_iterations = 12;
    if (candidate == 2 || candidate == 3 || candidate == 5 || candidate == 7) {
        return true;
    }
    if (candidate == 1 || candidate == 4 || candidate % 2 == 0 || candidate % 3 == 0 || candidate % 5 == 0 ||
        candidate % 7 == 0) {
        return false;
    }

    auto num = candidate - 1;
    unsigned long long degree = 0;
    while (num % 2 == 0) {
        ++degree;
        num /= 2;
    }

    for (int i = 0; i < accuracy_iterations; ++i) {
        unsigned long long a = 2 + rand() % (candidate - 4); //pick random

        a = power(a, num, candidate);
        if (a == 1 || a == candidate - 1) {
            continue;
        }
        long long step = 1;
        for (; step < degree; ++step) {
            a = moduloMultiply(a, a, candidate);
            if (a == 1) {
                return false;
            }
            if (a == candidate - 1) {
                break;
            }
        }
        if (step == degree)
            return false;
    }

    return true;
}

void test_1() {
    std::vector<long long> primes({2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
                                   73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
                                   157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
                                   239, 241, 251, 257, 263, 269, 271});

    for (auto prime: primes) {
        auto result = isPrime(prime);
        if (!result) {
            std::cout << prime << " marked composite" << std::endl;
        }
        assert(result);
    }
}

void test_2() {
    std::vector<long long> primes(
            {277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,
             409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541,
             547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661,
             673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821,
             823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929});

    for (auto prime: primes) {
        auto result = isPrime(prime);
        if (!result) {
            std::cout << prime << " marked composite" << std::endl;
        }
        assert(result);
    }
}

void test_3() {
    std::vector<long long> primes(
            {937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051,
             1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187,
             1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303,
             1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453,
             1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579,
             1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627});

    for (auto prime: primes) {
        auto result = isPrime(prime);
        if (!result) {
            std::cout << prime << " marked composite" << std::endl;
        }
        assert(result);
    }
}

void test_4() {
    std::vector<long long> primes(
            {1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783,
             1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931,
             1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069,
             2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213,
             2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347,
             2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411});

    for (auto prime: primes) {
        auto result = isPrime(prime);
        if (!result) {
            std::cout << prime << " marked composite" << std::endl;
        }
        assert(result);
    }
}

void test_5() {
    std::vector<long long> primes(
            {1294177, 1294199, 1294201, 1294231, 1294253, 1294273, 1294277, 1294301, 1294303, 1294309, 1294339, 1294351,
             1294361, 1294367, 1294369, 1294393, 1294399, 1294453, 1294459, 1294471, 1294477, 1294483, 1294561, 1294571,
             1294583, 1294597, 1294609, 1294621, 1294627, 1294633, 1294639, 1294649, 1294651, 1294691, 1294721, 1294723,
             1294729, 1294753, 1294757, 1294759, 1294817, 1294823, 1294841, 1294849, 1294939, 1294957, 1294967, 1294973,
             1294987, 1294999, 1295003, 1295027, 1295033, 1295051, 1295057, 1295069, 1295071, 1295081, 1295089, 1295113,
             1295131, 1295137, 1295159, 1295183, 1295191, 1295201, 1295207, 1295219, 1295221, 1295243, 1295263, 1295279,
             1295293, 1295297, 1295299, 1295309, 1295317, 1295321, 1295323, 1295339, 1295347, 1295369, 1295377, 1295387,
             1295389, 1295447, 1295473, 1295491, 1295501, 1295513, 1295533, 1295543, 1295549, 1295551, 1295561, 1295563,
             1295603, 1295611, 1295617, 1295639, 1295647, 1295653, 1295681, 1295711, 1295717, 1295737, 1295741, 1295747,
             1295761, 1295783, 1295803, 1295809, 1295813, 1295839, 1295849, 1295867, 1295869, 1295873, 1295881, 1295947,
             1295953, 1295989, 1295993, 1296007, 1296011, 1296019, 1296023, 1296037, 1296041, 1296059, 1296077, 1296089,
             1296101, 1296109, 1296137, 1296143, 1296167, 1296181, 1296187, 1296209, 1296227, 1296277, 1296283, 1296287,
             1296293, 1296319, 1296331, 1296341, 1296343, 1296371, 1296391, 1296409, 1296413, 1296419, 1296467, 1296473,
             1296481, 1296499, 1296511, 1296521, 1296523, 1296551, 1296557, 1296563, 1296571, 1296583, 1296587, 1296593,
             1296601, 1296613, 1296623, 1296629, 1296649, 1296679, 1296689, 1296703, 1296721, 1296727, 1296749, 1296781,
             1296787, 1296803, 1296817, 1296829, 1296833, 1296839, 1296877, 1296899, 1296907, 1296929, 1296949, 1296973,
             1296983, 1297001, 1297003, 1297013, 1297019, 1297027, 1297057, 1297061, 1297063, 1297091, 1297103, 1297123,
             1297129, 1297139, 1297147, 1297157, 1297169, 1297171, 1297193, 1297201, 1297211, 1297217, 1297229, 1297243,
             1297249, 1297271, 1297273, 1297279, 1297297, 1297313, 1297333, 1297337, 1297349, 1297357, 1297367, 1297369,
             1297393, 1297397, 1297399, 1297403, 1297411, 1297421, 1297447, 1297451, 1297459, 1297477, 1297487, 1297501,
             1297507, 1297519, 1297523, 1297537, 1297561, 1297573, 1297601, 1297607, 1297619, 1297631, 1297633, 1297649,
             1297651, 1297657, 1297669, 1297687, 1297693, 1297727, 1297739, 1297771, 1297781, 1297799, 1297841, 1297847,
             1297853, 1297873, 1297927, 1297963, 1297973, 1297979, 1297993, 1298027, 1298039, 1298047, 1298053, 1298057,
             1298111, 1298113, 1298117, 1298119, 1298131, 1298149, 1298161, 1298173, 1298191, 1298197, 1298221, 1298261,
             1298279, 1298291, 1298309, 1298317, 1298329, 1298333, 1298351, 1298357, 1298371, 1298387, 1298467, 1298489,
             1298491, 1298537, 1298551, 1298573, 1298581, 1298611, 1298617, 1298641, 1298651, 1298653, 1298699, 1298719,
             1298723, 1298747, 1298771, 1298779, 1298789, 1298797, 1298809, 1298819, 1298831, 1298849, 1298863, 1298887,
             1298909, 1298911, 1298923, 1298951, 1298963, 1298981, 1298989, 1299007, 1299013, 1299019, 1299029, 1299041,
             1299059, 1299061, 1299079, 1299097, 1299101, 1299143, 1299169, 1299173, 1299187, 1299203, 1299209, 1299211,
             1299223, 1299227, 1299257, 1299269, 1299283, 1299289, 1299299, 1299317, 1299323, 1299341, 1299343, 1299349,
             1299359, 1299367, 1299377, 1299379, 1299437, 1299439, 1299449, 1299451, 1299457, 1299491, 1299499, 1299533,
             1299541, 1299553, 1299583, 1299601, 1299631, 1299637, 1299647, 1299653, 1299673, 1299689, 1299709});

    for (auto prime: primes) {
        auto result = isPrime(prime);
        if (!result) {
            std::cout << prime << " marked composite" << std::endl;
        }
        assert(result);
    }
}

int main() {
    std::ios::sync_with_stdio(false), std::cin.tie(nullptr), std::cout.tie(nullptr);

//    test_1();
//    test_2();
//    test_3();
//    test_4();
//    test_5();

    unsigned long long int n;
    std::cin >> n;
    for (unsigned long long i = 0; i < n; ++i) {
        unsigned long long int candidate;
        std::cin >> candidate;
        if (isPrime(candidate)) {
            std::cout << "YES\n";
        } else {
            std::cout << "NO\n";
        }
    }

    return 0;
}
